[인덱스](#인덱스)

[인덱스 종류](#인덱스-종류)

[인덱스 사용 예시](#인덱스-사용-예시)

[다중 컬럼 인덱스](#다중-컬럼-인덱스-multi-column-index)

[인덱스 알고리즘](#인덱스-알고리즘)
- [B-Tree Index (Balanced-Tree Index)](#b-tree-index-balanced-tree-index)

[B-Tree 성능에 영향을 미치는 요소](#b-tree-성능에-영향을-미치는-요소)
- [인덱스 키 값의 크기](#인덱스-키-값의-크기)
- [선택도 (기수성)](#선택도-기수성)
- [레코드 건수](#레코드-건수)
- [최적화 팁](#최적화-팁)

[인덱스 스캔](#인덱스-스캔)
- [레인지 스캔 (Range Scan)](#레인지-스캔-range-scan)
- [커버링 스캔 (Index-Only Scan)](#커버링-스캔-index-only-scan)
- [풀 스캔 (Full Index Scan)](#풀-스캔-full-index-scan)
- [유니크 인덱스 조회 (Unique Index Lookup)](#유니크-인덱스-조회-unique-index-lookup)
- [루스 인덱스 조회 (Loose Index Scan)](#루스-인덱스-스캔-loose-index-scan)
- [인덱스 스킵 스캔 (Index Skip Scan)](#인덱스-스킵-스캔-index-skip-scan)

## 인덱스

데이터베이스 테이블에서 특정 컬럼 또는 특정 컬럼의 조합에 대한 빠른 조회 성능을 제공하는 데이터 구조를 인덱스라고 함

키-값 쌍의 구조를 가지는데, 키는 인덱싱된 컬럼의 값이고 값은 해당 레코드의 위치를 나타냄

인덱스는 검색, 정렬, 조인 등의 정렬을 빠르게 수행할 수 있도록 도와줌

인덱스가 없는 경우, MySQL은 테이블의 모든 레코드를 순차적으로 검색해야 하므로 성능이 저하될 수 있음

**색인**

인덱스는 책의 색인처럼 작동하는데, 색인에 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소가 됨

DBMS도 데이터베이스의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리므로, 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것임

**정렬 상태**

인덱스는 저장하는 순서대로 저장되지 않고, **항상 정렬된 상태를 유지**함

쓰기 작업(INSERT, UPDATE, DELETE)의 경우 인덱스의 값이 항상 정렬되어야 하므로 처리가 느려지지만 검색(SELECT) 속도가 향상됨

## 인덱스 종류

**기본 인덱스 (Primary Index)**

기본 키에 대한 인덱스임

테이블 당 하나만 존재하며, 기본 키는 고유성과 NULL 값을 허용하지 않음

**보조 인덱스 (Secondary Index)**

기본 키가 아닌 다른 컬럼에 대한 인덱스임

테이블 당 여러 개의 보조 인덱스를 가질 수 있음

다만 인덱스는 항상 정렬된 상태를 유지해야 되므로, 많은 보조 인덱스는 쓰기 작업의 속도 저하를 불러일으킬 수 있음

**유니크 인덱스 (Unique Index)**

기본 인덱스와 유사하게 인덱스 컬럼의 값이 중복되지 않도록 보장함 (고유성)

다만 NULL 값을 허용함

대체 키라고도 함

**전체 텍스트 인덱스 (Full-Text Index)**

텍스트 검색을 최적화하기 위해 사용됨

일반적으로 텍스트 데이터에서 특정 단어를 빠르게 검색할 때 유용함

## 인덱스 사용 예시

**기본 키만 지정하고, 별도의 인덱스를 만들지 않은 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id)
);
```

기본 키 인덱스만 생성됨(InnoDB는 기본 키를 클러스터형 인덱스로 사용)

**기본 키를 지정하지 않은 경우**

InnoDB 내부적으로 유니크한 클러스터형 인덱스를 생성함

**기본 키에 더해 유니크 인덱스나 세컨더리 인덱스를 추가한 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id),              # 기본 인덱스(클러스터형 인덱스)
    UNIQUE KEY unique_name (name), # name 컬럼에 대한 유니크 인덱스
    INDEX idx_age (age)            # age 컬럼에 대한 세컨더리 인덱스
);
```

각 인덱스 종류 별로 인덱스 구조가 생성되서, 검색 작업 및 쓰기 작업 시 쿼리에 따라 특정 인덱스를 사용함

## 다중 컬럼 인덱스 (Multi-Column Index)

2개 이상의 컬럼을 포함하는 인덱스임

각 인덱스 엔트리는 첫 번째 인덱스의 값에 의해 정렬됨

만약 첫 번째 인덱스의 값이 동일한 경우 그 다음 인덱스의 값으로 정렬을 시도하고, 

이 값도 동일하다면 그 다음 인덱스의 값으로 정렬을 시도하는 방식으로 인덱스 엔트리를 정렬함

그래서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요함

## 인덱스 알고리즘

인덱스를 효율적으로 사용하기 위한 알고리즘으로 각 종류마다 인덱스를 관리하는 데이터 구조와 방식이 상이함

### B-Tree Index (Balanced-Tree Index)

데이터베이스 인덱싱 알고리즘 중 가장 범용적으로 사용되는 알고리즘

데이터가 정렬된 순서로 저장됨

**B-Tree란**

<img src="./images/b-tree-binary-tree.png" alt="b-tree">

[출처](https://open4tech.com/b-tree-vs-binary-tree/)

b-tree의 트리 구조는 **루트 노드(Root Node)**를 시작으로 각 여러 자식 노드를 가질 수 있으며

가장 하위에 있는 노드를 **리프 노드(Leaf Node)**라고 하는데, 루트에서 리프 노트까지의 거리가 동일함

루트 노드도 아니고 리프 노드가 아닌 노드를 **브랜치 노드(Branch Node)**라고 함

**InnoDB의 B-Tree 인덱스**

B-Tree 구조를 사용하면 모든 리프 노드가 동일한 깊이를 가지므로 검색, 쓰기 작업 시 일정한 시간 복잡도를 보장하고, 비싼 디스크 I/O 작업을 줄일 수 있음
- B-Tree 인덱스의 루트 노드는 트리의 시작점으로, 모든 검색 작업의 시작점임
- 브랜치 노드는 인덱스 키 값과 하위 노드의 경로를 가짐
- 리프 노드는 인덱스 키 값(기본 키)을 저장함
  - 데이터 삽입으로 인해 리프 노드가 가득 차면 분할되어 트리 구조를 유지함

데이터 파일(테이블)에는 기본 키를 기준으로 하는 별도의 B-Tree가 구축되어 있고, 인덱스에 저장되어 있는 기본 키를 통해서 다시 한 번 더 검색한 후 기본 키 인덱스에 해당되는 리프 페이지에 저장된 레코드를
읽음

이걸 **클러스터형 인덱스**라고 함

**데이터베이스에 여러 인덱스가 존재할 때**

옵티마이저는 생성된 실행 계획에 따른 비용 계산 결과를 만드는데

여러 인덱스가 존재하면 비용 계산 결과를 바탕으로 가장 적합한 인덱스를 선택하여 인덱스 탐색을 진행함

**검색 및 쓰기 작업에 따른 B-Tree 인덱스 키 추가 및 삭제**

인덱스를 검색하는 작업을 **트리 탐색**이라고 함

트리 탐색은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행함

검색 작업 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 해당 레코드를 먼저 검색할 경우에도 인덱스 트리 탐색이 사용됨

B-Tree 인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우일 때와 부등호(`>`, `<`) 비교 조건에서 사용할 수 있음

- 검색
  - 기본 키 검색
    - `SELECT * FROM example WHERE id = 100;`
    - 클러스터형 인덱스에서 기본 키 값을 검색하고, 해당 리프 노드에서 데이터를 직접 읽음
  - 유니크 인덱스 검색
    - `SELECT * FROM example name = 'roro';`
    - 유니크 인덱스에서 name 값을 검색하고 리프 노드에서 기본 키를 찾은 다음, 클러스터형 인덱스를 통해 데이터를 읽음
    - 유니크 인덱스는 세컨더리 인덱스와 달리 컬럼에 대한 고유성을 보장함
  - 세컨더리 인덱스 검색
    - `SELECT * FROM example WHERE age = 30;`
    - 세컨더리 인덱스에서 age 값을 검색하고 리프 노드에서 기본 키를 찾은 다음 클러스터형 인덱스를 통해 데이터를 읽음
- 쓰기
  - 기본 키 쓰기(INSERT)
    - `INSERT INTO example (id, name, age) VALUES (1, "roro", 25);`
    - 새로운 기본 키 값을 인덱스에 추가하고, 리프 노드에 새로운 데이터 페이지를 생성하거나 기존 페이지에 데이터를 추가함
    - 인덱스 키 추가 작업은 레코드 추가 작업 비용보다 소모가 큼
    - 필요에 따라 **체인지 버퍼**를 활용해서 작업을 지연시킬 수 있으나, 기본 키와 유니크 인덱스의 경우 중복 체크가 필요하기 땜누에 즉시 B-Tree에 추가함
  - 유니크 인덱스 쓰기(UPDATE)
    - 유니크 인덱스 컬럼의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
    - 변경된 값이 이미 존재하는 경우, 유니크 제약 조건 위반으로 오류 발생
  - 세컨더리 인덱스 쓰기(UPDATE)
    - 세컨더리 인덱스 열의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
  - 인덱스 키 삭제
    - 삭제 마킹 처리만 하는데, 이 공간은 그대로 두거나 재활용할 수 있음

**유의사항**

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락은 

검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠금

만약 UPDATE, DELETE 쿼리가 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없는 경우 테이블의 모든 레코드를 잠글 수도 있음

따라서 InnoDB를 사용하는 경우 인덱스 설계가 중요함

**파생**

B-Tree의 변형으로 `B+-Tree`와 `B*-Tree`가 있음

### B+Tree Index

### Hash Index

## B-Tree 성능에 영향을 미치는 요소

- 인덱스를 구성하는 컬럼의 크기
- 레코드 건수
- 유니크 인덱스 키 값의 개수

### 인덱스 키 값의 크기

[페이지(블록)](./inno-db.md#pages)
- 디스크에 데이터를 저장하는 기본 단위
- 모든 읽기 및 쓰기 작업의 최소 단위
- InnoDB 버퍼 풀 버퍼링의 기본 단위

한 개의 인덱스 페이지에 저장할 수 있는 용량
- 인덱스 또한 다른 데이터처럼 페이지로 관리되므로 루트, 브랜치, 리프 노드를 구분하는 기준이 페이지임
- 페이지의 기본 값: 16KB
- 인덱스 엔트리의 키는 16바이트, 값(자식 노드 주소)은 12바이트 정도됨
- 16 * 1024 / (16 + 12) = 약 585개 (한 페이지에 저장할 수 있는 인덱스 엔트리의 개수)

인덱스 키 값의 크기가 늘어날 경우
- 16 * 1024 / (32 + 12) = 약 372개
1. 16 바이트 키 값보다 가져올 수 있는 레코드의 수가 줄어듬 -> 디스크 작업 한 번에 할 걸 두 번 이상 늘어나게 됨
2. 전체적인 인덱스 크기가 커짐 -> 인덱스를 캐시해두는 버퍼 풀의 크기는 제한적이므로 캐시할 수 있는 레코드 수가 줄어듬
3. 한 페이지에 저장할 수 있는 인덱스 엔트리의 수가 줄어듬 -> 동일한 양의 데이터를 저장하기 위한 더 많은 페이지를 필요로 하므로 트리의 높이 증가함

### 선택도 (기수성)

선택도(Selectivity), 기수성(Cardinality)는 인덱스의 유니크한 값의 수를 의미함

전체 레코드 수에 대한 유니크 값의 비율을 나타내는데, 선택도가 높을수록 인덱스는 더 많은 유니크한 값을 포함하고 있음을 의미함

```text
선택도 = 유니크한 값의 수 / 전체 레코드 수
```

테이블에 1천개의 레코드가 있고, 인덱스 컬럼에 900개의 유니크한 값이 있는 경우

(900 / 1000) * 100 = 90의 선택도를 가짐

여기서 유니크한 값은 특정 값이 동일하게 9백개가 있는 게 아니라, 각기 다른 값이 900개가 있다는 말임

선택도에 따른 쿼리 조회 성능 차이
- 기수성이 높은 경우
  - 많은 유니크한 값을 가지고 있는 경우에 해당됨
  - 높은 선택도는 쿼리가 특정 값을 찾을 때 더 적은 수의 레코드를 반환함을 의미함
  - 옵티마이저가 인덱스를 사용하여 레코드를 빠르게 필터링할 수 있게 해줌
  - 사용자 ID와 같은 유니한 값에 대한 기수성은 매우 높은 편
- 기수성이 낮은 경우
  - 유니크한 값이 적은 경우
  - 인덱스가 많은 중복 값을 포함하고 있음을 의미
  - 인덱스를 사용하더라도 많은 레코드를 스캔해야 함 -> 성능 저하
  - 성별, 상태 값의 경우 중복이 많으므로 기수성이 낮은 편

### 레코드 건수

옵티마이저는 쿼리를 실행할 때 인덱스를 사용할 지, 전체 테이블을 직접 스캔할지 결정함

이 결정은 비용 기반으로 이뤄지는데, 옵티마이저가 각각 실행 계획에 대해 예상되는 비용을 계산하고, 가장 낮은 비용의 계획을 선택함

일반적으로 읽어야 하는 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 다음의 이유로 인해 전체 테이블 스캔이 더 효율적이라고 판단할 수 있음
- 랜덤 I/O vs 순차 I/O
  - 인덱스를 사용하면 랜덤 I/O가 발생하게 됨
  - 이는 디스크에서 여러 위치를 찾아야 되므로 많은 비용이 발생됨
  - 반면 순차 I/O의 경우 한 번에 많은 데이터를 읽을 수 있음
  - 상당한 양의 레코드를 읽어야 하는 경우 순차 I/O가 효율적임
- 추가 비용
  - 인덱스를 통해 실제 데이터를 읽기 위해 추가적인 I/O 작업이 필요함
  - 테이블 스캔은 이러한 추가 작업 없이 한 번에 데이터를 읽음

### 최적화 팁

적절한 인덱스 설정
- 고유한 값을 가지는 컬럼에 인덱스를 설정해서 선택도를 높이면 옵티마이저가 빠르게 레코드를 필터링할 수 있음
- 쿼리에 자주 사용되는 컬럼에 인덱스를 설정하여, 옵티마이저가 인덱스를 사용하도록 유도

통계 정보 업데이트
- 테이블의 통계 정보를 주기적으로 업데이트하여 옵티마이저가 최신 정보를 기반으로 최적의 실행 계획을 선택할 수 있도록 함

쿼리 리팩토링
- 옵티마이저가 인덱스를 효율적으로 사용할 수 있도록 쿼리 최적화

## 인덱스 스캔

쿼리를 실행할 때 인덱스를 사용하여 데이터를 검색하는 방법을 **인덱스 스캔**이라고 함

### 레인지 스캔 (Range Scan)

인덱스 접근 방법 중 가장 대표적인 접근 방식으로 인덱스의 특정 범위를 스캔해서 필요한 데이터를 조회함

레인지 스캔 단계
1. 인덱스에서 조건을 만족하는 값을 찾음 - 인덱스 탐색(index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 순서대로 읽어들임 - 인덱스 스캔
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 읽은 후, 실제 레코드를 가져옴

실제 레코드를 가져올 때 레코드마다 랜덤 I/O가 발생하기 때문에 비용이 많이 드는 작업에 속함

레인지 스캔이 사용되는 상황
- WHERE 절에 범위 조건(BETWEEN, <, >, <=, >=)이 사용된 경우
- 인덱스의 선두 부분(Prefix)을 기준으로 범위 조건이 사용된 경우

불필요한 전체 테이블 스캔을 피하고, 필요한 범위만 스캔을 하므로 I/O 비용이 줄어듬

```mysql
SELECT * FROM employees WHERE employee_id BETWEEN 50000 AND 100000;
```

employee_id 컬럼에 인덱스가 설정되어 있다면 id 인덱스를 이용해서 범위 조건에 맞는 로우를 스캔함

### 커버링 스캔 (Index-Only Scan)

레인지 스캔 단계 중 세 번째 단계를 뺀 접근 방식

쿼리에서 필요한 모든 데이터가 인덱스 자체에 포함된 경우 디스크 I/O를 통해 실제 데이터 페이지를 읽지 않음

커버링 스캔이 사용되는 상황
- 인덱스만으로도 필요한 모든 데이터를 가져올 수 있는 상황
  - SELECT 절에 포함된 모든 열이 인덱스에 포함된 경우
  - WHERE 절이나 ORDER BY 절에 사용된 열이 인덱스에 포함된 경우

실제 데이터 페이지를 읽을 필요가 없으므로 낮은 I/O 비용을 가지며, 더 빠른 쿼리 성능을 제공함

```mysql
# 인덱스 생성
CREATE INDEX idx_emp_dept_name ON employees(department_id, first_name, last_name);

# 인덱스에 포함된 데이터만 조회
SELECT first_name, last_name
FROM employees
WHERE deparment_id = 10;
```

인덱스 `idx_emp_dept_name`은 deparment_id, first_name, last_name 컬럼을 모두 포함하고 있으므로, 커버링 인덱스 스캔이 사용됨

```mysql
SELECT first_name, last_name FROM employees WHERE department_id = 10;
```

### 풀 스캔 (Full Index Scan)

인덱스의 처음부터 끝까지 순차적으로 모든 인덱스 엔트리를 읽는 방식

풀 스캔이 사용되는 상황
- 테이블의 모든 로우를 읽어야 되는 상황
- 인덱스에 대한 범위 조건이 없는 경우
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우

인덱스의 크기는 테이블의 크기보다 작은 게 일반적이므로, 직접 테이블을 처음부터 끝까지 읽는 거(테이블 풀스캔)에 비해 효율적임

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 커버링 인덱스 스캔이 될 수 있음

인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 이 방식으로 처리되지 않음

```mysql
# 아래의 인덱스가 있다고 가정
CREATE INDEX idx_emp_dept_name ON employees(department_id, first_name, last_name);

# 테이블의 모든 로우를 조회 - 테이블 풀 스캔
SELECt * FROM employees;

# 인덱스에 대한 범위 조건 없이 조회 - 인덱스 풀 스캔 (커버링)
SELECT first_name, last_name FROM employees;

# 인덱스의 첫 번째 컬럼(deparment_id)을 조건절에 사용하지 않은 경우 - 인덱스 풀 스캔 (커버링)
SELECT last_name FROM employees WHERE first_name = 'John';
```

### 유니크 인덱스 조회 (Unique Index Lookup)

### 루스 인덱스 스캔 (Loose Index Scan)

특정 조건을 만족하는 인덱스 엔트리만 선택적으로 스캔하는 방식

옵티마이저가 그룹화나 중복 제거를 위해 인덱스의 전체 범위를 스캔하지 않고, 조건을 만족하는 최소한의 인덱스 엔트리만 스캔함

즉, 불필요한 인덱스 엔트리는 건너뛰고 조건에 맞는 인덱스 엔트리만 읽어서 성능을 최적화함

루스 인덱스 스캔이 사용되는 상황
- `GROUP BY`, `DISTINCT` 쿼리 
- 집합 함수 `MAX()`, `MIN()` 최적화

조건에 만족하는 인덱스를 읽으면 `WHERE` 조건을 만족하는 범위 전체를 다 스캔하지 않고 생략한 뒤, 다음 레코드로 이동함

루스 인덱스 스캔을 사용하려면 여러 가지 조건을 만족해야 됨

## 인덱스 스킵 스캔 (Index Skip Scan)

복합 인덱스를 사용할 때 인덱스의 선두 컬럼(primary column)이 쿼리 조건에 없더라도, 그 다음 컬럼으로 인덱스를 탐색하는 방식

인덱스 중간 열들만 사용해도 효율적으로 검색할 수 있게 해줌

동작 방식
- 선두 컬럼의 고유 값 순차 탐색
- 선두 컬럼이 쿼리 조건에 없는 경우, 선두 컬럼의 각 고유 값에 대해 다음 인덱스 컬럼을 사용하여 조건에 맞는 엔트리를 탐색

```mysql
# 예시 인덱스
CREATE INDEX idx_age_name ON employees(age, last_name);

# 인덱스의 선두 컬럼없이 조회
SELECT * FROM employees WHERE last_name = 'Anna';
```

위의 `SELECT` 쿼리를 실행하면 옵티마이저는 먼저 선두 컬럼인 age 컬럼의 유니크 값을 모두 조회함

그 다음 각 age 값에 대해 `last_name = 'Anna'` 조건을 만족하는 레코드를 탐색함

인덱스의 유연한 설계를 제공하지만, 선두 컬럼의 고유 값이 많은 경우 각 고유 값마다 후속 열을 탐색해야 하기 때문에 탐색 비용이 증가할 수 있음

-> 선두 컬럼이 가진 유니크 값의 개수가 소량일 때 적용 가능한 최적화라고 생각하면 됨(성별, 상태 값)
