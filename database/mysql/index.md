[인덱스](#인덱스)

[인덱스 종류](#인덱스-종류)

[인덱스 사용 예시](#인덱스-사용-예시)

[인덱스 알고리즘](#인덱스-알고리즘)
- [B-Tree Index (Balanced-Tree Index)](#b-tree-index-balanced-tree-index)

[B-Tree 성능에 영향을 미치는 요소](#b-tree-성능에-영향을-미치는-요소)
- [인덱스 키 값의 크기](#인덱스-키-값의-크기)
- [선택도 (기수성)](#선택도-기수성)
- [레코드 건수](#레코드-건수)

## 인덱스

데이터베이스 테이블에서 특정 컬럼 또는 특정 컬럼의 조합에 대한 빠른 조회 성능을 제공하는 데이터 구조를 인덱스라고 함

키-값 쌍의 구조를 가지는데, 키는 인덱싱된 컬럼의 값이고 값은 해당 레코드의 위치를 나타냄

인덱스는 검색, 정렬, 조인 등의 정렬을 빠르게 수행할 수 있도록 도와줌

인덱스가 없는 경우, MySQL은 테이블의 모든 레코드를 순차적으로 검색해야 하므로 성능이 저하될 수 있음

**색인**

인덱스는 책의 색인처럼 작동하는데, 색인에 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소가 됨

DBMS도 데이터베이스의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리므로, 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것임

**정렬 상태**

인덱스는 저장하는 순서대로 저장되지 않고, 항상 정렬된 상태를 유지함

쓰기 작업(INSERT, UPDATE, DELETE)의 경우 인덱스의 값이 항상 정렬되어야 하므로 처리가 느려지지만 검색(SELECT) 속도가 향상됨

## 인덱스 종류

**기본 인덱스 (Primary Index)**

기본 키에 대한 인덱스임

테이블 당 하나만 존재하며, 기본 키는 고유성과 NULL 값을 허용하지 않음

**보조 인덱스 (Secondary Index)**

기본 키가 아닌 다른 컬럼에 대한 인덱스임

테이블 당 여러 개의 보조 인덱스를 가질 수 있음

다만 인덱스는 항상 정렬된 상태를 유지해야 되므로, 많은 보조 인덱스는 쓰기 작업의 속도 저하를 불러일으킬 수 있음

**유니크 인덱스 (Unique Index)**

기본 인덱스와 유사하게 인덱스 컬럼의 값이 중복되지 않도록 보장함 (고유성)

다만 NULL 값을 허용함

대체 키라고도 함

**전체 텍스트 인덱스 (Full-Text Index)**

텍스트 검색을 최적화하기 위해 사용됨

일반적으로 텍스트 데이터에서 특정 단어를 빠르게 검색할 때 유용함

## 인덱스 사용 예시

**기본 키만 지정하고, 별도의 인덱스를 만들지 않은 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id)
);
```

기본 키 인덱스만 생성됨(InnoDB는 기본 키를 클러스터형 인덱스로 사용)

**기본 키를 지정하지 않은 경우**

InnoDB 내부적으로 유니크한 클러스터형 인덱스를 생성함

**기본 키에 더해 유니크 인덱스나 세컨더리 인덱스를 추가한 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id),              # 기본 인덱스(클러스터형 인덱스)
    UNIQUE KEY unique_name (name), # name 컬럼에 대한 유니크 인덱스
    INDEX idx_age (age)            # age 컬럼에 대한 세컨더리 인덱스
);
```

각 인덱스 종류 별로 인덱스 구조가 생성되서, 검색 작업 및 쓰기 작업 시 쿼리에 따라 특정 인덱스를 사용함

## 인덱스 알고리즘

인덱스를 효율적으로 사용하기 위한 알고리즘으로 각 종류마다 인덱스를 관리하는 데이터 구조와 방식이 상이함

### B-Tree Index (Balanced-Tree Index)

데이터베이스 인덱싱 알고리즘 중 가장 범용적으로 사용되는 알고리즘

데이터가 정렬된 순서로 저장됨

**B-Tree란**

<img src="./images/b-tree-binary-tree.png" alt="b-tree">

[출처](https://open4tech.com/b-tree-vs-binary-tree/)

b-tree의 트리 구조는 **루트 노드(Root Node)**를 시작으로 각 여러 자식 노드를 가질 수 있으며

가장 하위에 있는 노드를 **리프 노드(Leaf Node)**라고 하는데, 루트에서 리프 노트까지의 거리가 동일함

루트 노드도 아니고 리프 노드가 아닌 노드를 **브랜치 노드(Branch Node)**라고 함

인덱스의 리프 노드는 항상 실제 데이터 파일에 저장된 레코드를 찾아갈 수 있는 물리적인 주솟값을 가지고 있음

**InnoDB의 B-Tree 인덱스**

보조 인덱스는 기본 키가 아닌 다른 컬럼을 기준으로 B-Tree 구조를 형성하고, 리프 노드에 실제 데이터 레코드 주소 대신 기본 키를 저장함

데이터 파일(테이블)에는 기본 키를 기준으로 하는 별도의 B-Tree가 구축되어 있고, 인덱스에 저장되어 있는 기본 키를 통해서 다시 한 번 더 검색한 후 기본 키 인덱스에 해당되는 리프 페이지에 저장된 레코드를
읽음

이걸 **클러스터형 인덱스**라고 함

**검색 및 쓰기 작업에 따른 B-Tree 인덱스 키 추가 및 삭제**

인덱스를 검색하는 작업을 **트리 탐색**이라고 함

트리 탐색은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행함

검색 작업 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 해당 레코드를 먼저 검색할 경우에도 인덱스 트리 탐색이 사용됨

B-Tree 인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우일 때와 부등호(`>`, `<`) 비교 조건에서 사용할 수 있음

- 검색
  - 기본 키 검색
    - `SELECT * FROM example WHERE id = 100;`
    - 클러스터형 인덱스에서 기본 키 값을 검색하고, 해당 리프 노드에서 데이터를 직접 읽음
  - 유니크 인덱스 검색
    - `SELECT * FROM example name = 'roro';`
    - 유니크 인덱스에서 name 값을 검색하고 리프 노드에서 기본 키를 찾은 다음, 클러스터형 인덱스를 통해 데이터를 읽음
    - 유니크 인덱스는 세컨더리 인덱스와 달리 컬럼에 대한 고유성을 보장함
  - 세컨더리 인덱스 검색
    - `SELECT * FROM example WHERE age = 30;`
    - 세컨더리 인덱스에서 age 값을 검색하고 리프 노드에서 기본 키를 찾은 다음 클러스터형 인덱스를 통해 데이터를 읽음
- 쓰기
  - 기본 키 쓰기(INSERT)
    - `INSERT INTO example (id, name, age) VALUES (1, "roro", 25);`
    - 새로운 기본 키 값을 인덱스에 추가하고, 리프 노드에 새로운 데이터 페이지를 생성하거나 기존 페이지에 데이터를 추가함
    - 인덱스 키 추가 작업은 레코드 추가 작업 비용보다 소모가 큼
    - 필요에 따라 **체인지 버퍼**를 활용해서 작업을 지연시킬 수 있으나, 기본 키와 유니크 인덱스의 경우 중복 체크가 필요하기 땜누에 즉시 B-Tree에 추가함
  - 유니크 인덱스 쓰기(UPDATE)
    - 유니크 인덱스 컬럼의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
    - 변경된 값이 이미 존재하는 경우, 유니크 제약 조건 위반으로 오류 발생
  - 세컨더리 인덱스 쓰기(UPDATE)
    - 세컨더리 인덱스 열의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
  - 인덱스 키 삭제
    - 삭제 마킹 처리만 하는데, 이 공간은 그대로 두거나 재활용할 수 있음

**유의사항**

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락은 

검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠금

만약 UPDATE, DELETE 쿼리가 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없는 경우 테이블의 모든 레코드를 잠글 수도 있음

따라서 InnoDB를 사용하는 경우 인덱스 설계가 중요함

**파생**

B-Tree의 변형으로 `B+-Tree`와 `B*-Tree`가 있음

### B+Tree Index

### Hash Index

## B-Tree 성능에 영향을 미치는 요소

- 인덱스를 구성하는 컬럼의 크기
- 레코드 건수
- 유니크 인덱스 키 값의 개수

### 인덱스 키 값의 크기

[페이지(블록)](./inno-db.md#pages)
- 디스크에 데이터를 저장하는 기본 단위
- 모든 읽기 및 쓰기 작업의 최소 단위
- InnoDB 버퍼 풀 버퍼링의 기본 단위

한 개의 인덱스 페이지에 저장할 수 있는 용량
- 인덱스 또한 다른 데이터처럼 페이지로 관리되므로 루트, 브랜치, 리프 노드를 구분하는 기준이 페이지임
- 페이지의 기본 값: 16KB
- 인덱스 엔트리의 키는 16바이트, 값(자식 노드 주소)은 12바이트 정도됨
- 16 * 1024 / (16 + 12) = 약 585개 (한 페이지에 저장할 수 있는 인덱스 엔트리의 개수)

인덱스 키 값의 크기가 늘어날 경우
- 16 * 1024 / (32 + 12) = 약 372개
1. 16 바이트 키 값보다 가져올 수 있는 레코드의 수가 줄어듬 -> 디스크 작업 한 번에 할 걸 두 번 이상 늘어나게 됨
2. 전체적인 인덱스 크기가 커짐 -> 인덱스를 캐시해두는 버퍼 풀의 크기는 제한적이므로 캐시할 수 있는 레코드 수가 줄어듬
3. 한 페이지에 저장할 수 있는 인덱스 엔트리의 수가 줄어듬 -> 동일한 양의 데이터를 저장하기 위한 더 많은 페이지를 필요로 하므로 트리의 높이 증가함

### 선택도 (기수성)

선택도(Selectivity), 기수성(Cardinality)는 인덱스의 유니크한 값의 수를 의미함

전체 레코드 수에 대한 유니크 값의 비율을 나타내는데, 선택도가 높을수록 인덱스는 더 많은 유니크한 값을 포함하고 있음을 의미함

```text
선택도 = 유니크한 값의 수 / 전체 레코드 수
```

테이블에 1천개의 레코드가 있고, 인덱스 컬럼에 900개의 유니크한 값이 있는 경우

(900 / 1000) * 100 = 90의 선택도를 가짐

여기서 유니크한 값은 특정 값이 동일하게 9백개가 있는 게 아니라, 각기 다른 값이 900개가 있다는 말임

선택도에 따른 쿼리 조회 성능 차이
- 기수성이 높은 경우
  - 많은 유니크한 값을 가지고 있는 경우에 해당됨
  - 높은 선택도는 쿼리가 특정 값을 찾을 때 더 적은 수의 레코드를 반환함을 의미함
  - 옵티마이저가 인덱스를 사용하여 레코드를 빠르게 필터링할 수 있게 해줌
  - 사용자 ID와 같은 유니한 값에 대한 기수성은 매우 높은 편
- 기수성이 낮은 경우
  - 유니크한 값이 적은 경우
  - 인덱스가 많은 중복 값을 포함하고 있음을 의미
  - 인덱스를 사용하더라도 많은 레코드를 스캔해야 함 -> 성능 저하
  - 성별, 상태 값의 경우 중복이 많으므로 기수성이 낮은 편

### 레코드 건수

옵티마이저는 쿼리를 실행할 때 인덱스를 사용할 지, 전체 테이블을 직접 스캔할지 결정함

이 결정은 비용 기반으로 이뤄지는데, 옵티마이저가 각각 실행 계획에 대해 예상되는 비용을 계산하고, 가장 낮은 비용의 계획을 선택함

일반적으로 읽어야 하는 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 다음의 이유로 인해 전체 테이블 스캔이 더 효율적이라고 판단할 수 있음
- 랜덤 I/O vs 순차 I/O
  - 인덱스를 사용하면 랜덤 I/O가 발생하게 됨
  - 이는 디스크에서 여러 위치를 찾아야 되므로 많은 비용이 발생됨
  - 반면 순차 I/O의 경우 한 번에 많은 데이터를 읽을 수 있음
  - 상당한 양의 레코드를 읽어야 하는 경우 순차 I/O가 효율적임
- 추가 비용
  - 인덱스를 통해 실제 데이터를 읽기 위해 추가적인 I/O 작업이 필요함
  - 테이블 스캔은 이러한 추가 작업 없이 한 번에 데이터를 읽음

### 최적화 팁

적절한 인덱스 설정
- 고유한 값을 가지는 컬럼에 인덱스를 설정해서 선택도를 높이면 옵티마이저가 빠르게 레코드를 필터링할 수 있음
- 쿼리에 자주 사용되는 컬럼에 인덱스를 설정하여, 옵티마이저가 인덱스를 사용하도록 유도

통계 정보 업데이트
- 테이블의 통계 정보를 주기적으로 업데이트하여 옵티마이저가 최신 정보를 기반으로 최적의 실행 계획을 선택할 수 있도록 함

쿼리 리팩토링
- 옵티마이저가 인덱스를 효율적으로 사용할 수 있도록 쿼리 최적화