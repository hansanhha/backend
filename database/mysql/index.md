[인덱스](#인덱스)

[인덱스 종류](#인덱스-종류)

[인덱스 사용 예시](#인덱스-사용-예시)

[인덱스 알고리즘](#인덱스-알고리즘)

## 인덱스

데이터베이스 테이블에서 특정 컬럼 또는 특정 컬럼의 조합에 대한 빠른 조회 성능을 제공하는 데이터 구조를 인덱스라고 함

키-값 쌍의 구조를 가지는데, 키는 인덱싱된 컬럼의 값이고 값은 해당 레코드의 위치를 나타냄

인덱스는 검색, 정렬, 조인 등의 정렬을 빠르게 수행할 수 있도록 도와줌

인덱스가 없는 경우, MySQL은 테이블의 모든 레코드를 순차적으로 검색해야 하므로 성능이 저하될 수 있음

**색인**

인덱스는 책의 색인처럼 작동하는데, 색인에 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소가 됨

DBMS도 데이터베이스의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리므로, 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것임

**정렬 상태**

인덱스는 저장하는 순서대로 저장되지 않고, 항상 정렬된 상태를 유지함

쓰기 작업(INSERT, UPDATE, DELETE)의 경우 인덱스의 값이 항상 정렬되어야 하므로 처리가 느려지지만 검색(SELECT) 속도가 향상됨

## 인덱스 종류

**기본 인덱스 (Primary Index)**

기본 키에 대한 인덱스임

테이블 당 하나만 존재하며, 기본 키는 고유성과 NULL 값을 허용하지 않음

**보조 인덱스 (Secondary Index)**

기본 키가 아닌 다른 컬럼에 대한 인덱스임

테이블 당 여러 개의 보조 인덱스를 가질 수 있음

다만 인덱스는 항상 정렬된 상태를 유지해야 되므로, 많은 보조 인덱스는 쓰기 작업의 속도 저하를 불러일으킬 수 있음

**유니크 인덱스 (Unique Index)**

기본 인덱스와 유사하게 인덱스 컬럼의 값이 중복되지 않도록 보장함 (고유성)

다만 NULL 값을 허용함

대체 키라고도 함

**전체 텍스트 인덱스 (Full-Text Index)**

텍스트 검색을 최적화하기 위해 사용됨

일반적으로 텍스트 데이터에서 특정 단어를 빠르게 검색할 때 유용함

## 인덱스 사용 예시

**기본 키만 지정하고, 별도의 인덱스를 만들지 않은 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id)
);
```

기본 키 인덱스만 생성됨(InnoDB는 기본 키를 클러스터형 인덱스로 사용)

**기본 키를 지정하지 않은 경우**

InnoDB 내부적으로 유니크한 클러스터형 인덱스를 생성함

**기본 키에 더해 유니크 인덱스나 세컨더리 인덱스를 추가한 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id),              # 기본 인덱스(클러스터형 인덱스)
    UNIQUE KEY unique_name (name), # name 컬럼에 대한 유니크 인덱스
    INDEX idx_age (age)            # age 컬럼에 대한 세컨더리 인덱스
);
```

각 인덱스 종류 별로 인덱스 구조가 생성되서, 검색 작업 및 쓰기 작업 시 쿼리에 따라 특정 인덱스를 사용함

## 인덱스 알고리즘

인덱스를 효율적으로 사용하기 위한 알고리즘으로 각 종류마다 인덱스를 관리하는 데이터 구조와 방식이 상이함

### B-Tree Index (Balanced-Tree Index)

데이터베이스 인덱싱 알고리즘 중 가장 범용적으로 사용되는 알고리즘

데이터가 정렬된 순서로 저장됨

**B-Tree란**

<img src="./images/b-tree-binary-tree.png" alt="b-tree">

[출처](https://open4tech.com/b-tree-vs-binary-tree/)

b-tree의 트리 구조는 **루트 노드(Root Node)**를 시작으로 각 여러 자식 노드를 가질 수 있으며

가장 하위에 있는 노드를 **리프 노드(Leaf Node)**라고 하는데, 루트에서 리프 노트까지의 거리가 동일함

루트 노드도 아니고 리프 노드가 아닌 노드를 **브랜치 노드(Branch Node)**라고 함

인덱스의 리프 노드는 항상 실제 데이터 파일에 저장된 레코드를 찾아갈 수 있는 물리적인 주솟값을 가지고 있음

**InnoDB의 B-Tree 인덱스**

보조 인덱스는 기본 키가 아닌 다른 컬럼을 기준으로 B-Tree 구조를 형성하고, 리프 노드에 실제 데이터 레코드 주소 대신 기본 키를 저장함

데이터 파일(테이블)에는 기본 키를 기준으로 하는 별도의 B-Tree가 구축되어 있고, 인덱스에 저장되어 있는 기본 키를 통해서 다시 한 번 더 검색한 후 기본 키 인덱스에 해당되는 리프 페이지에 저장된 레코드를
읽음

이걸 **클러스터형 인덱스**라고 함

**검색 및 쓰기 작업에 따른 B-Tree 인덱스 키 추가 및 삭제**

인덱스를 검색하는 작업을 **트리 탐색**이라고 함

트리 탐색은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행함

검색 작업 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 해당 레코드를 먼저 검색할 경우에도 인덱스 트리 탐색이 사용됨

B-Tree 인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우일 때와 부등호(`>`, `<`) 비교 조건에서 사용할 수 있음

- 검색
  - 기본 키 검색
    - `SELECT * FROM example WHERE id = 100;`
    - 클러스터형 인덱스에서 기본 키 값을 검색하고, 해당 리프 노드에서 데이터를 직접 읽음
  - 유니크 인덱스 검색
    - `SELECT * FROM example name = 'roro';`
    - 유니크 인덱스에서 name 값을 검색하고 리프 노드에서 기본 키를 찾은 다음, 클러스터형 인덱스를 통해 데이터를 읽음
    - 유니크 인덱스는 세컨더리 인덱스와 달리 컬럼에 대한 고유성을 보장함
  - 세컨더리 인덱스 검색
    - `SELECT * FROM example WHERE age = 30;`
    - 세컨더리 인덱스에서 age 값을 검색하고 리프 노드에서 기본 키를 찾은 다음 클러스터형 인덱스를 통해 데이터를 읽음
- 쓰기
  - 기본 키 쓰기(INSERT)
    - `INSERT INTO example (id, name, age) VALUES (1, "roro", 25);`
    - 새로운 기본 키 값을 인덱스에 추가하고, 리프 노드에 새로운 데이터 페이지를 생성하거나 기존 페이지에 데이터를 추가함
    - 인덱스 키 추가 작업은 레코드 추가 작업 비용보다 소모가 큼
    - 필요에 따라 **체인지 버퍼**를 활용해서 작업을 지연시킬 수 있으나, 기본 키와 유니크 인덱스의 경우 중복 체크가 필요하기 땜누에 즉시 B-Tree에 추가함
  - 유니크 인덱스 쓰기(UPDATE)
    - 유니크 인덱스 컬럼의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
    - 변경된 값이 이미 존재하는 경우, 유니크 제약 조건 위반으로 오류 발생
  - 세컨더리 인덱스 쓰기(UPDATE)
    - 세컨더리 인덱스 열의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
  - 인덱스 키 삭제
    - 삭제 마킹 처리만 하는데, 이 공간은 그대로 두거나 재활용할 수 있음

**유의사항**

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락은 

검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠금

만약 UPDATE, DELETE 쿼리가 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없는 경우 테이블의 모든 레코드를 잠글 수도 있음

따라서 InnoDB를 사용하는 경우 인덱스 설계가 중요함

B-Tree의 변형으로 `B+-Tree`와 `B*-Tree`가 있음

### B+Tree Index

### Hash Index
