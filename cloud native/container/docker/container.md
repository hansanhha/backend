[Container](#container)

[Container vs Virtual Machine](#container-vs-virtual-machine)

[Isolated Container](#isolated-container)

[Docker Workflow, Components](#docker-workflow-components)

[Docker Lifecycle (Event State)](#docker-lifecycle-event-state)

[Docker Container Network](#docker-container-network)


## Container

컨테이너는 애플리케이션과 그 실행에 필요한 모든 리소스(라이브리러, 종속성 등)를 하나의 패키지로 묶어서

언제 어디서나 동일환 환경에서 실행할 수 있게 하는 환경임

각 컨테이너은 이미지(패키징된 애플리케이션 및 관련 리소스)를 실행할 가상의 컴퓨터(호스트 이름, IP주소, 디스크 드라이브, 파일 시스템 등)라고 생각하면 됨

또한 컨테이너마다 서로 독립적인 환경을 갖지만 컨테이너가 실행되는 컴퓨터의 자원(CPU, 메모리, 운영체제)을 공유함

키워드
- Self-Contained
- Isolated
- Independent
- Portable

## Container vs Virtual Machine

컨테이너와 가상 머신은 두 가지 목적을 달성해야 제 기능을 한다고 볼 수 있음

애플리케이션 간 서로 독립된 환경에서 실행되어야 한다는 **격리(islocation)**와

컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행할 수 있어야 한다는 **밀집(density)**임

애플리케이션이 실행될 독립적 환경이 생긴다는 점에서 컨테이너와 가상 머신 둘 다 격리성을 가짐

다만 컨테이너의 경우 여러 격리된 컨테이너들이 동일한 호스트의 자원을 공유하는 데에 반해,

가상 머신은 호스트의 운영체제를 공유하지 않고 별도의 운영체제를 필요로 함

각각의 가상 머신은 자신만의 운영체제를 별도로 갖기 때문에 다음과 같은 단점이 있음
- 애플리케이션이 사용해야 할 CPU와 메모리를 가상머신이 차지함
- 라이선스 비용 및 OS 업데이트에 대한 부담이 생김

따라서 컨테이너는 밀집성을 가지지만, 가상 머신은 가질 수 없게 됨 

## Isolated Container

컨테이너가 클라우드 네이티브 환경에서 좋은 이유는

마이크로서비스 아키텍처를 적용한 애플리케이션의 여러 컴포넌트들을 격리된 환경에서 개발/테스트/운영을 할 수 있고, 그 즉시 바로 실행할 수 있는 상태이기 때문임

**문제 격리**

컨테이너는 독립된 환경이므로 한 컴포넌트의 장애가 다른 컴포넌트에 영향을 미치지 않음

**의존성 관리**

각 컨테이너 별로 자체적인 의존성을 가지므로, 버전 충돌이나 종속성 문제를 피할 수 있음 

**독립적 배포**

업데이트가 필요한 경우 전체 시스템을 중단하지 않고 대상 컨테이너만 독립적으로 배포할 수 있음

**다양한 개발 환경**

애플리케이션 서비스를 구현하는 데 서로 다른 프로그래밍 언어/프레임워크를 사용할 수 있음

**테스트**

컨테이너 별로 독립적으로 테스트할 수 있음

문제 발생 시 특정 컴포넌트에서 원인을 쉽게 찾을 수 있음

**보안**

각 컴포넌트에 대해 별도의 보안 정책을 적용할 수 있음
  - 외부 네트워크와의 접근은 웹 서버 컨테이너만 허용하고, 데이터베이스는 내부 네트워크에서만 접근하도록 제한

각 컨테이너가 자신에게 필요한 권한만을 가지도록 설정해서 보안 위협을 줄일 수 있음

**유연성**
- 트래픽이 많아질 때 특정 컴포넌트만 스케일링 할 수 있음
- 각 컴포넌트는 필요한 자원만 할당받아 사용하므로 자원의 효율을 높일 수 있음

**이식성/자동화**
- 컨테이너는 언제 어디서나 동일한 환경을 제공하므로, 개발/테스트/운영 환경 간의 차이를 최소화할 수 있음 (개발자와 비개발자의 협업 개선)
- CI/CD 파이프라인에 쉽게 통합/테스트/배포 가능

## Docker Workflow, Components

1. 도커 이미지 빌드
2. 도커 레지스트리에 공유
3. 도커 이미지 실행

애플리케이션을 실행 가능한 상태로 만든 후(이미지 빌드) 레지스트리에 공유하면, 레지스트리를 통해 이미지를 다운받아 바로 실행할 수 있음

도커를 구성하고 있는 요소들은 다음과 같음
- Docker Daemon
  - 도커의 핵심 백그라운드 서비스로, 컨테이너 생성/관리, 이미지 빌드/저장 등을 실제로 수행하는 역할을 함
  - 클라이언트의 요청(도커 API)을 받아 처리한 뒤 결과를 응답함
- Docker Client
  - 도커 클라이언트(`docker` 명령어)는 사용자가 도커 데몬과 상호작용할 수 있게 해주는 요소임
  - 사용자는 Docker CLI나 Docker Desktop을 통해 도커 데몬과 REST API로 통신함
  - 요청을 전송하면 데몬이 처리한 후, 그 결과를 REST API 응답으로 도커 클라이언트에게 반환하고 이 응답은 CLI나 Desktop에서 GUI로 확인할 수 있음
- Docker Image
  - 도커 이미지는 컨테이너를 실행하기 위한 모든 파일과 메타데이터를 포함한 읽기 전용 템플릿임
  - 이미지는 여러 레이어로 구성되며, 각각의 레이어는 파일 시스템 스냅샷을 포함함
  - 이미지를 기반으로 컨테이너를 생성할 수 있음
  - 이미지는 Docker hub와 같은 공개 레지스트리나 사설 레지스트리에서 관리되며, 이를 통해 이미지를 공유하고 배포할 수 있음
- Docker Container
  - 도커 컨테이너는 도커 이미지를 통해 생성한 독립된 실행 환경임
  - 컨테이너는 격리된 공간에서 애플리케이션과 의존성을 실행하며, 호스트와 리소스를 공유하지만 독립적으로 동작함
  - 호스트와 리소스를 공유하므로, 호스트 컴퓨터의 운영체제에 따라 실행환경이 결정됨(윈도우 컴퓨터에서 실행하면 윈도우, 맥이나 리눅스에서 실행하면 리눅스)
- Dockerfile
  - 도커 파일은 도커 이미지를 빌드하기 위한 설정 파일임
  - 베이스 이미지, 애플리케이션 파일, 의존성, 실행 명령어 등이 포함되며, 이를 통해 이미지를 자동으로 생성할 수 있음
- Docker Compose
  - 도커 컴포즈는 여러 컨테이너를 정의하고 다룰 수 있게 해주는 도구임
  - `docker-compose.yml` 파일을 통해 여러 서비스(컨테이너)를 정의하고, 하나의 명령어로 이들을 함께 시작하거나 중지할 수 있음
- Docker Swarm
  - 도커 스웜은 도커의 네이티브 오케스트레이션 도구로, 여러 도커 호스트에서 컨테이너를 클러스터링하고 관리함
  - 스웜 모드를 사용하면 여러 도커 데몬을 클러스터로 구성하고, 이 클러스터 내에서 서비스를 배포 및 관리할 수 있음
- Docker Network
  - 도커 네트워크는 컨테이너 간 또는 컨테이너와 외부 간의 네트워크 통신을 관리함
  - 브릿지(Bridge), 호스트(Host), 오버레이(Overlay) 등의 네트워크 드라이버를 사용하여 컨테이너 네트워크를 구성함
  - 기본적으로 외부 네트워크의 접근으로부터 격리되어 있음
- Docker Volume
  - 도커 볼륨은 컨테이너가 데이터를 저장하기 위해 사용하는 메커니즘임
  - 볼륨은 컨테이너 간에 데이터를 공유하거나, 컨테이너가 종료돼도 데이터를 유지하도록 함
- Docker Registry
  - 도커 레지스트리는 도커 이미지를 저장하고 배포하는 시스템임
  - 공개 레지스트리: Docker Hub 등
- Docker Engine
  - 도커 엔진은 전체 도커 플랫폼을 구성하는 핵심 컴포넌트로, 항시 동작하는 백그라운드 프로세스임
  - 도커 데몬, API, CLI를 포함하며 이미지와 컨테이너를 관리, 빌드, 실행, 배포하는 모든 작업을 담당함
  - 컨테이너를 실행하기 위해 새로운 이미지가 필요하면 이미지를 다운받으며, 로컬에 기존 이미지가 있다면 "도커 이미지 캐시"에서 이미지를 꺼내와 사용함
  - 도커 API(REST API)를 통해 맡은 기능을 수행함
  - 도커 엔진의 설정을 통해 네트워크를 경유해 외부 컴퓨터에서 도커 API를 호출하거나 막을 수 있음
- containered
  - 컨테이너를 실제로 관리하는 역할임
  - 호스트 운영체제가 제공하는 기능을 통해 컨테이너를 만듦
  - CNCF에서 관리하는 오픈 소스 프로젝트이며, 컨테이너는 개방형 컨테이너 이니셔티브(Open Container Initiative)라는 이름으로 공개된 개방형 표준임

## Docker Lifecycle (Event State)

<img src="./images/docker-event-state.png" alt="docker event state" />

[출처](https://docker-saigon.github.io/post/Docker-Internals/#overview-of-container-runtimes:cb6baf67dddd3a71c07abfd705dc7d4b)

생성(created) -> 실행(start) -> 일시 정지(pause)/재개(unpause) -> 정지(stop) -> 재시작(restart) 또는 삭제(remove)

**created**
- 이미지로부터 컨테이너가 생성된 상태
- 파일 시스템이 설정되고, 네트워크와 볼륨이 준비됐지만 애플리케이션 실행이 되지 않은 상태
- `docker create`

**running**
- 생성된 컨테이너를 실행하여 애플리케이션을 시작한 상태
- 이 때 컨테이너 내부에서 정의된 프로세스가 시작됨
- `docker start`: 생성된 컨테이너 실행
- `docker run`: 생성과 실행을 동시에 수행

**paused**
- 실행 중인 컨테이너의 모든 프로세스를 일시적으로 멈춘 상태, 다시 시작될 때까지 정지 상태가 유지됨
- CPU 사용을 중지하지만, 메모리와 상태는 그대로 유지됨
- `docker pause`

**running (unpause)**
- 일시 정지된 컨테이너의 프로세스를 다시 재개한 상태
- `docker unpause`

**exited (stop)**
- 실행 중인 컨테이너를 종료한 상태
- 컨테이너는 운영체제의 `SIGTERM` 신호를 받아 정상적으로 종료됨
- 프로세스가 종료되고, 컨테이너는 멈추지만 삭제되지 않고 호스트 디스크에 남아 있음
- `docker stop`

**exited (kill)**
- 컨테이너를 즉시 강제 종료한 상태
- 정상 종료 신호 상태가 아닌 `SIGKILL` 신호가 전송되어 프로세스가 즉시 종료됨
- `docker kill`

**running (restart)**
- 종료된 컨테이너를 다시 시작한 상태
- docker stop 후 다시 시작할 때 유용함
- `docker restart`

## Docker Container Network

기본적으로 컨테이너는 호스트 컴퓨터에 연결된 IP 주소와 다른 주소(도커 내부에만 존재하는 가상의 IP 주소)를 가지며 외부 환경에 노출되지 않음

따라서 호스트 컴퓨터와 연결된 컨테이너의 네트워크 주소에 접근할 수 없음

도커는 호스트 컴퓨터에서 발생된 네트워크 트래픽에 접근하여 필요한 것을 컨테이너에게 전달할 수 있는데

컨테이너가 호스트 컴퓨터에게 포트를 공개한 경우, 도커가 해당 포트로 들어오는 트래픽을 컨테이너로 전달해줘서 외부로부터의 접근을 허용함

## Docker Registry

## Docker Images

- Layered File System(image layer)
- Immutable

## Dockerfile

instruction

build context

multi-stage builds

[docker docs](https://docs.docker.com/guides/docker-concepts/the-basics/what-is-a-container/)
