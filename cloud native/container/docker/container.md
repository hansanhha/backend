[컨테이너](#컨테이너)

[컨테이너 vs 가상머신](#컨테이너-vs-가상-머신)

[격리된 컨테이너의 장점](#격리된-컨테이너의-장점)

## 컨테이너

컨테이너는 애플리케이션과 그 실행에 필요한 모든 리소스(라이브리러, 종속성 등)을 하나의 패키지로 묶어서

언제 어디서나 동일환 환경에서 실행할 수 있게 하는 환경임

각 컨테이너마다 애플리케이션과 실행할 가상의 컴퓨터(호스트 이름, IP주소, 디스크 드라이브, 파일 시스템 등)가 함께 들어 있으며

컨테이너마다 서로 독립적인 환경을 갖지만 컨테이너가 실행되는 컴퓨터의 자원(CPU, 메모리, 운영체제)을 공유함

키워드
- Self-Contained
- Isolated
- Independent
- Portable

## 컨테이너 vs 가상 머신

컨테이너와 가상 머신은 두 가지 목적을 달성해야 제 기능을 한다고 볼 수 있음

하나는 애플리케이션은 서로 독립된 환경에서 실행되어야 한다는 **격리(islocation)**와

컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행할 수 있어야 한다는 **밀집(density)**임

애플리케이션이 실행될 독립적 환경이 생긴다는 점에서 컨테이너와 가상 머신은 격리성을 가짐

다만 컨테이너의 경우 여러 격리된 컨테이너들이 동일한 호스트의 자원을 공유하는 데에 반해,

가상 머신은 호스트의 운영체제를 공유하지 않고 별도의 운영체제를 필요로 함

각각의 가상 머신은 자신만의 운영체제를 별도로 갖기 때문에 다음과 같은 단점이 있음
- 애플리케이션이 사용해야 할 CPU와 메모리를 가상머신이 차지함
- 라이선스 비용 및 OS 업데이트에 대한 부담이 생김

따라서 컨테이너는 밀집성을 가지지만, 가상 머신은 가질 수 없게 됨 

## 격리된 컨테이너의 장점

컨테이너가 클라우드 네이티브 환경에서 좋은 이유는

마이크로서비스 아키텍처를 적용한 애플리케이션의 여러 컴포넌트들을 분리해서 개발/테스트/운영을 할 수 있고, 그 즉시 바로 실행할 수 있는 상태이기 때문임

**문제 격리**

컨테이너는 독립된 환경이므로 한 컴포넌트의 장애가 다른 컴포넌트에 영향을 미치지 않음

**의존성 관리**

각 컨테이너 별로 자체적인 의존성을 가지므로, 버전 충돌이나 종속성 문제를 피할 수 있음 

**독립적 배포**

업데이트가 필요한 경우 전체 시스템을 중단하지 않고 대상 컨테이너만 독립적으로 배포할 수 있음

**다양한 개발 환경**

애플리케이션 서비스를 구현하는 데 서로 다른 프로그래밍 언어/프레임워크를 사용할 수 있음

**테스트**

컨테이너 별로 독립적으로 테스트할 수 있음

문제 발생 시 특정 컴포넌트에서 원인을 쉽게 찾을 수 있음

**보안**

각 컴포넌트에 대해 별도의 보안 정책을 적용할 수 있음
  - 외부 네트워크와의 접근은 웹 서버 컨테이너만 허용하고, 데이터베이스는 내부 네트워에서만 접근하도록 제한

각 컨테이너가 자신에게 필요한 권한만을 가지도록 설정해서 보안 위협을 줄일 수 있음

**유연성**
- 트래픽이 많아질 때 특정 컴포넌트만 스케일링 할 수 있음
- 각 컴포넌트는 필요한 자원만 할당받아 사용하므로 자원의 효율을 높일 수 있음

**이식성/자동화**
- 컨테이너는 언제 어디서나 동일한 환경을 제공하므로, 개발/테스트/운영 환경 간의 차이를 최소화할 수 있음 (개발자와 비개발자의 협업 개선)
- CI/CD 파이프라인에 쉽게 통합/테스트/배포 가능

### Docker Container Lifecycle

## Docker Registry

## Docker Images

- Layered File System(image layer)
- Immutable

## Dockerfile

instruction

build context

multi-stage builds

[docker docs](https://docs.docker.com/guides/docker-concepts/the-basics/what-is-a-container/)
